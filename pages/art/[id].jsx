/* eslint-disable @next/next/no-img-element */
import { useEffect, useState } from "react";
import { useRouter } from "next/router";
import { backendClient } from "@/services/backendClient";
import Layout from "@/components/Layout";
import ImageCard from "@/components/molecules/ImageCard";
import ArtImage from "@/components/molecules/ArtImage";
import { storeFile } from "@/lib/ipfs";
import { STATUS_OK_TEXT } from "@/services/responseConstants";

const STATUS_INITIATING = "initiating";
const STATUS_READY = "ready";
const STATUS_PENDING = "pending";
const STATUS_SUCCESS = "success";
const STATUS_ERROR = "error";

export default function ArtPage() {
  const router = useRouter();
  const { id } = router.query;

  const [art, setArt] = useState();
  const [nft, setNft] = useState();
  const [status, setStatus] = useState(STATUS_INITIATING);
  const [mintablesLeft, setMintablesLeft] = useState(-1);

  useEffect(() => {
    async function getArt() {
      const response = await backendClient.get(`art/${id}`);
      setArt(response.result);
      setStatus(STATUS_READY);
    }
    getArt();
  }, []);

  useEffect(() => {
    async function getNft(nftId) {
      const response = await backendClient.get(`nft/${nftId}`);
      setNft(response.result);
    }
    if (art?.nftId) {
      getNft(art?.nftId);
    }
  }, [art]);

  const mintNft = async () => {
    if (status === STATUS_PENDING) {
      console.log("Work in progress...");
      return;
    }
    setStatus(STATUS_PENDING);
    // Check stuff... like...is it minted? how many? does it have Meta on ispf?
    const {
      imageUrl,
      seed,
      date,
      headline,
      prompt,
      version,
      model,
      modelVersion,
    } = art;

    if (!nft) {
      // Ok, first step is to prep metadata and put to IPFS:
      const meta = {
        artId: id,
        imageUrl,
        headline,
        seed,
        date,
        prompt,
        version,
        model,
        modelVersion,
        // include "MAX_SUPPLY"?
      };
      const storeFileResponse = await storeFile({
        imageUrl,
        meta,
        useMock: true,
      });
      const { url: ipfsUrl, ipnft } = storeFileResponse;

      const createResult = await backendClient.post("nft", {
        body: {
          ipfsUrl,
          cid: ipnft,
          artId: id,
          prompt,
          version,
          model,
          modelVersion,
          seed,
          headline,
          date,
          imageUrl,
        },
      });
      setNft(createResult.result);

      // Now lets update art with the nft db-reference:
      await backendClient.put(`art/${id}`, {
        body: {
          ...art,
          nftId: createResult.result.id,
        },
      });
    } else if (typeof nft.mintedCount === "undefined") {
      console.log("Lets add this art to the contract:", nft);
      // Add art to NFT contract:
      const backendResponseAddArt = await backendClient.post("hre/nft", {
        body: {
          metaUrl: nft.ipfsUrl,
          artId: nft.artId,
        },
      });
      console.log("backendResponseAddArt:", backendResponseAddArt);
      const updatedNft = {
        ...nft,
        mintedCount: 0,
      };
      await backendClient.put(`nft/${nft.id}`, {
        body: updatedNft,
      });
      setNft(updatedNft);
    } else {
      console.log("lets do mint!");

      const mintResponse = await backendClient.post("hre/mint", {
        body: { artId: art.id },
      });
      console.log("mintResponse:", mintResponse);
      if (mintResponse.status === STATUS_OK_TEXT) {
        await backendClient.put(`nft/${nft.id}`, {
          body: {
            ...nft,
            mintedCount: nft.mintedCount + 1,
          },
        });
      }
      // setStatus(STATUS_SUCCESS);
      // check transaction here: https://goerli.etherscan.io/tx/${mintResponse.result.hash}
    }
    setStatus(STATUS_READY);
  };

  useEffect(() => {
    async function getArtDataFromContract(artId) {
      const response = await backendClient.get(`hre/nft/by-art/${artId}`);
      console.log("response.result.art.counter", response.result.art.counter);
      setMintablesLeft(5 - response.result.art.counter);
    }
    if (art?.id) {
      getArtDataFromContract(art?.id);
    }
  }, [art]);

  if (status === STATUS_INITIATING) {
    return <>Loading...</>;
  }

  const { headline, votes, date, imageUrl, seed, selected } = art;

  let ipfsImageSrc;
  if (nft?.meta?.image) {
    ipfsImageSrc = `/api/nft/image?src=${encodeURIComponent(nft.meta.image)}`;
  }
  console.log({ mintablesLeft });
  return (
    <Layout
      title={`Art ${id}`}
      description="This art was generated by an AI with the input of an wordly event of its date. Now embrace its uniquenes and become its owner!"
    >
      <main style={{ padding: 16, textAlign: "-webkit-center" }}>
        <ImageCard key={id}>
          <ImageCard.Heading>{headline}</ImageCard.Heading>
          <ImageCard.Image>
            <ArtImage
              imageUrl={ipfsImageSrc || imageUrl}
              alt={headline}
              size="available"
              ipfs={!!ipfsImageSrc}
            />
          </ImageCard.Image>
          {status === STATUS_PENDING}
          <ImageCard.PropsWrapper>
            <ImageCard.ButtonProp
              onClick={mintNft}
              disabled={mintablesLeft === 0}
              loading={status === STATUS_PENDING}
            >
              Mint NFT
              <br />
              {mintablesLeft > -1 ? `(${mintablesLeft} of 5 left)` : ""}
            </ImageCard.ButtonProp>
            <ImageCard.SelectProp
              type="art"
              id={id}
              selected={selected}
              closed={true}
            />
            <ImageCard.VoteProp
              type="art"
              id={id}
              votes={votes}
              closed={true}
            />
            <ImageCard.Prop>{seed}</ImageCard.Prop>
            <ImageCard.Prop>{date}</ImageCard.Prop>
          </ImageCard.PropsWrapper>
        </ImageCard>
        <section>
          <div>
            If the art above has a green left border, it is an healthy
            indication of it being hosted on the decetralized ipfs network. If
            not, a red thin border is shown.
          </div>
        </section>
      </main>
    </Layout>
  );
}
